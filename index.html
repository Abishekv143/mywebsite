<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Meteor Impact</title>
<style>
  body { margin: 0; overflow: hidden; background: black; }
  canvas { display: block; }
  #restartBtn {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 40px;
    height: 40px;
    background: #fff;
    border-radius: 50%;
    text-align: center;
    line-height: 40px;
    font-weight: bold;
    cursor: pointer;
    user-select: none;
    box-shadow: 0 0 10px #fff;
    z-index: 10;
  }
  #restartBtn:hover { background: #ff6600; color: #fff; }
</style>
</head>
<body>
<div id="restartBtn">&#10227;</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>

<script>
let scene, camera, renderer, world;
let planetMesh, planetBody;
let meteorMesh, meteorBody;
let chunks = [];
let impactHappened = false;
const planetRadius = 3;
let stars;

initScene();

function initScene() {
    scene = new THREE.Scene();

    // Camera & Renderer
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 12;

    if(!renderer) {
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
    }

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const light1 = new THREE.DirectionalLight(0xffffff, 1);
    light1.position.set(10, 10, 10);
    scene.add(light1);
    const light2 = new THREE.DirectionalLight(0xffffff, 0.5);
    light2.position.set(-10, 5, -5);
    scene.add(light2);

    // Starfield
    addStars();

    // Cannon.js physics
    world = new CANNON.World();
    world.gravity.set(0, -9.82, 0);

    // Mars planet
    const marsTexture = new THREE.TextureLoader().load("https://threejsfundamentals.org/threejs/resources/images/mars_1k_color.jpg");
    const planetGeometry = new THREE.SphereGeometry(planetRadius, 64, 64);
    const planetMaterial = new THREE.MeshPhongMaterial({ map: marsTexture });
    planetMesh = new THREE.Mesh(planetGeometry, planetMaterial);
    scene.add(planetMesh);

    planetBody = new CANNON.Body({ mass: 0, shape: new CANNON.Sphere(planetRadius) });
    world.addBody(planetBody);

    // Meteor
    createMeteor();

    chunks = [];
    impactHappened = false;

    animate();
}

function addStars() {
    if(stars) scene.remove(stars); // remove old stars
    const starGeometry = new THREE.BufferGeometry();
    const starCount = 2000;
    const positions = [];
    for (let i=0; i<starCount; i++){
        positions.push((Math.random()-0.5)*2000);
        positions.push((Math.random()-0.5)*2000);
        positions.push((Math.random()-0.5)*2000);
    }
    starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1 });
    stars = new THREE.Points(starGeometry, starMaterial);
    scene.add(stars);
}

function createMeteor() {
    if(meteorMesh) scene.remove(meteorMesh);
    if(meteorBody) world.remove(meteorBody);

    const meteorGeometry = new THREE.IcosahedronGeometry(0.2,0);
    const posAttr = meteorGeometry.attributes.position;
    for(let i=0;i<posAttr.count;i++){
        posAttr.setXYZ(
            i,
            posAttr.getX(i)+(Math.random()-0.5)*0.1,
            posAttr.getY(i)+(Math.random()-0.5)*0.1,
            posAttr.getZ(i)+(Math.random()-0.5)*0.1
        );
    }
    meteorGeometry.attributes.position.needsUpdate = true;
    meteorGeometry.computeVertexNormals();

    const meteorMaterial = new THREE.MeshPhongMaterial({color:0x888888});
    meteorMesh = new THREE.Mesh(meteorGeometry, meteorMaterial);
    scene.add(meteorMesh);

    meteorBody = new CANNON.Body({ mass:1, shape:new CANNON.Sphere(0.2), position:new CANNON.Vec3(0,6,0)});
    meteorBody.angularVelocity.set(Math.random(), Math.random(), Math.random());
    meteorBody.angularDamping = 0.1;
    world.addBody(meteorBody);
}

function spawnChunks(position){
    for(let i=0;i<25;i++){
        const size=Math.random()*0.15;
        const geom=new THREE.BoxGeometry(size,size,size);
        const mat=new THREE.MeshPhongMaterial({color:0x882200});
        const mesh=new THREE.Mesh(geom,mat);
        scene.add(mesh);

        const body=new CANNON.Body({
            mass:0.2,
            shape:new CANNON.Box(new CANNON.Vec3(size/2,size/2,size/2)),
            position:new CANNON.Vec3(position.x, position.y, position.z)
        });
        body.velocity.set((Math.random()-0.5)*12, Math.random()*12, (Math.random()-0.5)*12);
        world.addBody(body);
        chunks.push({mesh, body});
    }
}

function createExplosion(position){
    const light = new THREE.PointLight(0xffaa33,5,20);
    light.position.copy(position);
    scene.add(light);
    let intensity=5;
    const interval=setInterval(()=>{
        intensity-=0.2;
        light.intensity=intensity;
        if(intensity<=0){
            scene.remove(light);
            clearInterval(interval);
        }
    },100);
}

function addCrater(position){
    const craterGeo = new THREE.CircleGeometry(1,32);
    const craterMat = new THREE.MeshBasicMaterial({color:0x111111});
    const craterMesh = new THREE.Mesh(craterGeo, craterMat);
    craterMesh.position.copy(position.clone().normalize().multiplyScalar(planetRadius+0.01));
    craterMesh.lookAt(planetMesh.position);
    craterMesh.rotation.z = Math.random()*Math.PI*2;
    scene.add(craterMesh);
}

function animate(){
    requestAnimationFrame(animate);
    world.step(1/60);

    meteorMesh.position.copy(meteorBody.position);
    meteorMesh.quaternion.copy(meteorBody.quaternion);

    chunks.forEach(obj=>{
        obj.mesh.position.copy(obj.body.position);
        obj.mesh.quaternion.copy(obj.body.quaternion);
    });

    if(!impactHappened && meteorBody.position.y<=planetRadius+0.2){
        impactHappened=true;
        spawnChunks(meteorBody.position);
        createExplosion(meteorBody.position);
        addCrater(meteorBody.position);
        scene.remove(meteorMesh);
        world.remove(meteorBody);
    }

    renderer.render(scene,camera);
}

document.getElementById("restartBtn").addEventListener("click", ()=>{
    // remove old chunks
    chunks.forEach(c=>{
        scene.remove(c.mesh);
        world.remove(c.body);
    });
    chunks=[];
    createMeteor();
    impactHappened=false;
});
window.addEventListener("resize",()=>{
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
