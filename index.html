
Mars simulation 


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mars Impact Simulation</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    #restart {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 40px;
      height: 40px;
      cursor: pointer;
      z-index: 10;
    }
  </style>
</head>
<body>
  <!-- Restart symbol (circular arrow) -->
  <svg id="restart" viewBox="0 0 24 24" fill="white">
    <path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6a6 6 0 01-6 6 6 6 0 01-6-6H4a8 8 0 008 8 8 8 0 008-8c0-4.42-3.58-8-8-8z"/>
  </svg>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

  <script>
    let scene, camera, renderer, mars, meteor, meteorTrail, debris = [], crashed = false;

    function init() {
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.z = 15;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Stars background
      const starGeometry = new THREE.BufferGeometry();
      const starCount = 2000;
      const positions = [];
      for (let i = 0; i < starCount; i++) {
        positions.push((Math.random() - 0.5) * 2000);
        positions.push((Math.random() - 0.5) * 2000);
        positions.push((Math.random() - 0.5) * 2000);
      }
      starGeometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
      const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1 });
      const stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(stars);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0x888888);
      scene.add(ambientLight);
      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(5, 5, 5);
      scene.add(dirLight);

      // Mars with texture
      const textureLoader = new THREE.TextureLoader();
      const marsTexture = textureLoader.load("mars_texture.jpg");
      const marsMaterial = new THREE.MeshStandardMaterial({ map: marsTexture });
      const marsGeometry = new THREE.SphereGeometry(5, 64, 64);
      mars = new THREE.Mesh(marsGeometry, marsMaterial);
      mars.position.set(-3, 0, 0);
      scene.add(mars);

      // Meteor
      const meteorGeometry = new THREE.IcosahedronGeometry(0.3, 0);
      const meteorMaterial = new THREE.MeshStandardMaterial({ color: 0xff5500 });
      meteor = new THREE.Mesh(meteorGeometry, meteorMaterial);
      meteor.position.set(8, 3, 0);
      scene.add(meteor);

      // Meteor fiery trail
      const trailGeometry = new THREE.ConeGeometry(0.6, 2, 16, 1, true);
      const trailMaterial = new THREE.MeshBasicMaterial({
        color: 0xff6600,
        transparent: true,
        opacity: 0.7,
        side: THREE.DoubleSide
      });
      meteorTrail = new THREE.Mesh(trailGeometry, trailMaterial);
      meteorTrail.rotation.x = Math.PI;
      meteor.add(meteorTrail);
      meteorTrail.position.y = 1;

      crashed = false;
      debris = [];
    }

    function animate() {
      requestAnimationFrame(animate);

      // Spin Mars (right to left)
      mars.rotation.y -= 0.002;

      if (!crashed) {
        meteor.position.x -= 0.05;
        meteor.position.y -= 0.02;

        // Collision detection
        const dist = meteor.position.distanceTo(mars.position);
        if (dist < 5.2) {
          scene.remove(meteor);
          crashed = true;

          // Add dark crater patch
          const craterGeometry = new THREE.CircleGeometry(0.8, 32);
          const craterMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 });
          const crater = new THREE.Mesh(craterGeometry, craterMaterial);
          crater.position.set(5, 0, 0);
          crater.rotation.y = Math.PI / 2;
          mars.add(crater);

          // Debris particles
          const debrisGeometry = new THREE.SphereGeometry(0.05, 6, 6);
          const debrisMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
          for (let i = 0; i < 30; i++) {
            const piece = new THREE.Mesh(debrisGeometry, debrisMaterial);
            piece.position.copy(mars.position);
            const velocity = new THREE.Vector3(
              (Math.random() - 0.5) * 0.2,
              (Math.random() - 0.5) * 0.2,
              (Math.random() - 0.5) * 0.2
            );
            debris.push({ mesh: piece, velocity });
            scene.add(piece);
          }
        }
      } else {
        debris.forEach(d => {
          d.mesh.position.add(d.velocity);
          d.velocity.multiplyScalar(0.98); // slow down gradually
        });
      }

      renderer.render(scene, camera);
    }

    document.getElementById("restart").onclick = () => {
      document.body.removeChild(renderer.domElement);
      init();
    };

    init();
    animate();
  </script>
</body>
</html>
