<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mars Impact — Crater Dent + Gradient Trail</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    /* restart as circular icon */
    #restart {
      position: absolute;
      top: 16px;
      right: 16px;
      width: 44px;
      height: 44px;
      background: rgba(255,85,0,0.9);
      color: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 22px;
      z-index: 10;
      user-select: none;
      box-shadow: 0 4px 10px rgba(0,0,0,0.5);
      transition: transform .18s;
    }
    #restart:hover { transform: rotate(20deg); }
  </style>
</head>
<body>
  <div id="restart" title="Restart">&#x21bb;</div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

  <script>
  // --------- CONFIG ----------
  const MARS_TEXTURE = 'mars_texture.jpg'; // put file in same folder
  const PLANET_RADIUS = 5;
  // ---------------------------

  let scene, camera, renderer;
  let mars, meteor, meteorTrail;
  let debris = [];
  let crashed = false;
  let trailMaterial;

  init();
  animate();

  function init(){
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0, 1.8, 16);

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // lights
    scene.add(new THREE.AmbientLight(0x888888));
    const dl = new THREE.DirectionalLight(0xffffff, 1.0);
    dl.position.set(6, 6, 4);
    scene.add(dl);

    // starfield (static)
    const starsGeo = new THREE.BufferGeometry();
    const starCount = 1600;
    const pos = new Float32Array(starCount * 3);
    for(let i=0;i<starCount;i++){
      pos[i*3+0] = (Math.random()-0.5) * 2000;
      pos[i*3+1] = (Math.random()-0.5) * 2000;
      pos[i*3+2] = (Math.random()-0.5) * 2000;
    }
    starsGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    const stars = new THREE.Points(starsGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 1 }));
    scene.add(stars);

    // Mars (texture)
    const texLoader = new THREE.TextureLoader();
    const marsTex = texLoader.load(MARS_TEXTURE, undefined, undefined, (err)=> {
      console.error('Texture load problem. Make sure', MARS_TEXTURE, 'is in the same folder and served by a local server.');
    });
    const marsMat = new THREE.MeshStandardMaterial({ map: marsTex });
    const marsGeo = new THREE.SphereGeometry(PLANET_RADIUS, 128, 128);
    mars = new THREE.Mesh(marsGeo, marsMat);
    mars.position.set(-3, 0, 0);
    scene.add(mars);

    // prepare meteor
    const mGeo = new THREE.IcosahedronGeometry(0.35, 0);
    const mMat = new THREE.MeshStandardMaterial({ color: 0xff8a33, flatShading: true });
    meteor = new THREE.Mesh(mGeo, mMat);
    meteor.position.set(10, 3, 0);
    scene.add(meteor);

    // shader trail material (gradient along cone)
    trailMaterial = new THREE.ShaderMaterial({
      transparent: true,
      side: THREE.DoubleSide,
      depthWrite: false,
      uniforms: {
        color1: { value: new THREE.Color(0xffff66) }, // near meteor (yellow)
        color2: { value: new THREE.Color(0xff8a33) }, // mid (orange)
        color3: { value: new THREE.Color(0xaa2200) }, // tip (red)
        opacity: { value: 1.0 }
      },
      vertexShader: `
        varying float vY;
        void main(){
          vY = position.y; // cone local Y from -h/2..h/2 typically
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.);
        }
      `,
      fragmentShader: `
        uniform vec3 color1; uniform vec3 color2; uniform vec3 color3; uniform float opacity;
        varying float vY;
        void main(){
          // vY ranges roughly -1..1 depending geometry; map to 0..1
          float t = smoothstep(-1.0, 1.0, vY);
          // color from tip (red) to base (yellow) - reverse as needed
          vec3 col = mix(color3, color2, t);
          col = mix(col, color1, t*0.6);
          float alpha = (1.0 - t) * opacity;
          gl_FragColor = vec4(col, alpha);
        }
      `
    });

    // meteor trail geometry: cone that points backward (attach to meteor)
    const trailGeo = new THREE.ConeGeometry(0.9, 3.0, 32, 1, true);
    meteorTrail = new THREE.Mesh(trailGeo, trailMaterial);
    meteorTrail.rotation.x = Math.PI; // point backwards
    meteorTrail.position.y = -0.6;    // offset behind meteor center (adjust visually)
    meteor.add(meteorTrail);

    // restart handler
    document.getElementById('restart').onclick = () => {
      // remove renderer and re-init to reset everything
      if(renderer && renderer.domElement) document.body.removeChild(renderer.domElement);
      // clear arrays
      debris = [];
      init(); // re-init scene (function scoped) — re-runs setup
    };

    // window resize
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    }, { passive: true });

    // ensure meteor trail follows meteor: trail is child of meteor so it follows automatically
  } // init

  // movement setup: meteor moves straight to mars center
  const meteorPos = new THREE.Vector3(10, 3, 0);
  const meteorTarget = new THREE.Vector3(-3, 0, 0); // mars.position
  const speedMag = 0.25;
  const meteorDir = new THREE.Vector3().subVectors(meteorTarget, meteorPos).normalize();
  const meteorVelocity = meteorDir.clone().multiplyScalar(speedMag);

  // helpful: spawn crater dent (rim + recessed dark inner)
  function spawnCraterDent(worldHitPos){
    // compute normal and local position on mars surface
    const dir = new THREE.Vector3().subVectors(worldHitPos, mars.position).normalize();

    // Rim ring (slightly above surface so visible)
    const rimGeo = new THREE.RingGeometry(0.65, 0.95, 48);
    const rimMat = new THREE.MeshStandardMaterial({ color: 0x4a2b12, side: THREE.DoubleSide });
    const rim = new THREE.Mesh(rimGeo, rimMat);
    rim.position.copy(dir.clone().multiplyScalar(PLANET_RADIUS + 0.03).add(mars.position));
    rim.lookAt(mars.position);
    rim.rotateX(Math.PI); // orientation fix
    mars.add(rim);

    // Inner recessed patch: a circular dark cap positioned slightly *inward* along normal
    const innerGeo = new THREE.CircleGeometry(0.6, 32);
    const innerMat = new THREE.MeshStandardMaterial({ color: 0x1a0e07 }); // dark-brown almost black
    const inner = new THREE.Mesh(innerGeo, innerMat);
    // position slightly recessed (inside) so visually looks dented
    inner.position.copy(dir.clone().multiplyScalar(PLANET_RADIUS - 0.06).add(mars.position));
    inner.lookAt(mars.position.clone().add(dir)); // face outward
    mars.add(inner);

    // subtle shading: add a small darker cap slightly above inner to hide seam (optional)
    // done: rim + inner produce dent-like look
  }

  // spawn debris evenly (spherical distribution) as THREE Meshes with velocities
  function spawnDebris(worldPos){
    const count = 28;
    for(let i=0;i<count;i++){
      const geo = new THREE.BoxGeometry(0.12, 0.12, 0.12);
      const mat = new THREE.MeshStandardMaterial({ color: 0x8a4a1a });
      const piece = new THREE.Mesh(geo, mat);
      piece.position.copy(worldPos);
      // spherical distribution
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      const spd = 0.18 + Math.random() * 0.18;
      const vx = spd * Math.sin(phi) * Math.cos(theta);
      const vy = spd * Math.cos(phi);
      const vz = spd * Math.sin(phi) * Math.sin(theta);
      debris.push({ mesh: piece, vel: new THREE.Vector3(vx, vy, vz) });
      scene.add(piece);
    }
  }

  // small impact flash (bright point light + quick fade)
  function impactFlash(worldPos){
    const light = new THREE.PointLight(0xffcc77, 3, 14, 2);
    light.position.copy(worldPos);
    scene.add(light);
    // animate fade quickly
    let t = 0;
    const iv = setInterval(()=>{
      t += 1;
      light.intensity *= 0.65;
      if(t>8){
        scene.remove(light);
        clearInterval(iv);
      }
    }, 30);
  }

  // animation loop
  function animate(){
    requestAnimationFrame(animate);

    // spin mars right-to-left
    if(mars) mars.rotation.y -= 0.0022;

    // move meteor until crash
    if(!crashed && meteor){
      meteor.position.add(meteorVelocity);

      // keep the trail attached and aligned: trail is child so follows; small orient tweak so cone points opposite velocity
      const lookTarget = new THREE.Vector3().addVectors(meteor.position, meteorVelocity);
      meteor.lookAt(lookTarget); // meteor faces toward target; trail is rotated on init

      // detect impact with planet center (distance to center)
      const dist = meteor.position.distanceTo(mars.position);
      if(dist <= PLANET_RADIUS * 1.02){
        // impact!
        crashed = true;
        // remove meteor & trail
        scene.remove(meteor);

        // compute hit position on surface toward planet center
        const hitDir = new THREE.Vector3().subVectors(meteor.position, mars.position).normalize();
        const hitWorldPos = hitDir.clone().multiplyScalar(PLANET_RADIUS).add(mars.position);

        // flash
        impactFlash(hitWorldPos);

        // debris
        spawnDebris(hitWorldPos);

        // crater dent (rim + inner)
        spawnCraterDent(hitWorldPos);
      }
    }

    // update debris flight physics (simple Euler move + slow down)
    for(let i = debris.length -1; i >=0; i--){
      const d = debris[i];
      d.mesh.position.add(d.vel);
      // simple damping
      d.vel.multiplyScalar(0.995);
      // optional remove if too far or too slow
      if(d.mesh.position.distanceTo(mars.position) > 60 || d.vel.length() < 0.005){
        // keep them small but allow them to linger; optional removal:
        // scene.remove(d.mesh);
        // debris.splice(i,1);
      }
    }

    renderer.render(scene, camera);
  }

  // initial run
  function init(){
    // clear previous scene if exists
    scene = null; camera = null; renderer = null; mars = null; meteor = null; debris = []; crashed = false;
    // restart by reloading page would be cleaner; here reload content by re-creating canvas
    // but to keep this simple: just reload the page for a fresh start
    location.reload();
  }

  // If user clicked restart top-right, we reload page — easier to reset everything
  document.getElementById('restart').addEventListener('click', ()=> location.reload());

  </script>
</body>
</html>
