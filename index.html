<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Definitive Scientific Impact Simulation - Bengaluru</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@400;600;700&family=Roboto+Mono&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; background-color: #000; color: #fff; font-family: 'Exo 2', sans-serif; overflow: hidden; }
        canvas { display: block; }
        @keyframes subtleGlow { 0%, 100% { border-color: rgba(0, 255, 255, 0.3); box-shadow: 0 0 15px rgba(0, 255, 255, 0.2); } 50% { border-color: rgba(0, 255, 255, 0.5); box-shadow: 0 0 25px rgba(0, 255, 255, 0.4); } }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        #overlay-container { 
            position: fixed; 
            inset: 0; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            background-image: url('https://images.unsplash.com/photo-1451187580459-43490279c0fa?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=2072&q=80');
            background-size: cover;
            background-position: center;
            z-index: 100; 
            transition: opacity 0.5s ease-out; 
        }
        .card { 
            background: rgba(10, 20, 30, 0.75); 
            padding: 2.5rem; 
            border-radius: 16px; 
            width: 450px; 
            box-shadow: 0 10px 50px rgba(0,0,0,0.8); 
            border: 1px solid rgba(0, 255, 255, 0.3); 
            backdrop-filter: blur(12px); 
            animation: fadeIn 0.7s ease-out, subtleGlow 4s infinite; 
        }
        .card h1 { margin: 0 0 0.5rem 0; font-size: 28px; text-align: center; color: #00ffff; font-weight: 700; letter-spacing: 1px; text-shadow: 0 0 10px rgba(0, 255, 255, 0.5); }
        .card p.subtitle { font-family: 'Roboto Mono', monospace; font-size: 14px; text-align: center; color: #ccc; margin-bottom: 2rem; }
        .card .hint { font-size: 12px; color: #888; text-align: center; margin-top:1.5rem; padding-top: 1rem; border-top: 1px solid rgba(0, 255, 255, 0.2);}
        .field { margin-bottom: 1.25rem; }
        .field label { display: flex; justify-content: space-between; font-size: 14px; color: #eee; margin-bottom: 0.75rem; font-weight: 600; font-family: 'Roboto Mono', monospace;}
        input[type=range] { width: 100%; -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-runnable-track { height: 4px; background: rgba(0, 255, 255, 0.2); border-radius: 2px; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 20px; width: 20px; background: #00ffff; border-radius: 50%; margin-top: -8px; border: 3px solid #0a141e; cursor: pointer; transition: transform 0.2s ease; box-shadow: 0 0 10px rgba(0, 255, 255, 0.7); }
        input[type=range]:hover::-webkit-slider-thumb { transform: scale(1.1); }
        button { width: 100%; padding: 0.85rem; border-radius: 8px; border: 1px solid #00ffff; cursor: pointer; font-weight: 700; font-size: 16px; background: rgba(0, 255, 255, 0.2); color: #00ffff; margin-top: 1rem; transition: all 0.3s ease; text-shadow: 0 0 5px rgba(0, 255, 255, 0.7); }
        button:hover { background: rgba(0, 255, 255, 0.4); box-shadow: 0 0 20px rgba(0, 255, 255, 0.5); transform: translateY(-2px); }
        #data-overlay { position: fixed; top: 20px; left: 20px; background: rgba(0,0,0,0.5); padding: 10px 15px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.1); font-family: 'Roboto Mono', monospace; font-size: 14px; z-index: 10; display: none; backdrop-filter: blur(5px); }
        #data-overlay p { margin: 0 0 5px 0; } #data-overlay p:last-child { margin-bottom: 0; }
        #data-overlay span { font-weight: 700; color: #00ffff; }
        #impact-report { position: fixed; bottom: 20px; left: 20px; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px; border: 1px solid rgba(255,85,85,0.3); font-size: 14px; z-index: 10; display: none; backdrop-filter: blur(5px); width: 320px; animation: fadeIn 0.5s ease-out; }
        #impact-report h2 { margin: 0 0 10px 0; color: #ff5555; font-size: 18px; text-align: center; }
        #impact-report p { margin: 0 0 5px 0; display: flex; justify-content: space-between; font-family: 'Roboto Mono', monospace; }
        #impact-report span { font-weight: 700; color: #ffb86c;}
        #restart-button { position: fixed; top: 20px; right: 20px; width: 50px; height: 50px; border-radius: 50%; display: none; align-items: center; justify-content: center; z-index: 10; cursor: pointer; background: rgba(255, 85, 85, 0.8); color: #fff; border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 0 15px rgba(255, 85, 85, 0.5); font-size: 24px; transition: all 0.3s ease; }
        #restart-button:hover { transform: rotate(360deg) scale(1.1); }
    </style>
</head>
<body>
    <div id="overlay-container">
        <div class="card">
            <h1>Impact Simulation</h1>
            <p class="subtitle">Target: Bengaluru, India // 05 OCT 2025 12:02 IST</p>
            <div class="field">
                <label for="size"><span>Asteroid Diameter</span><span id="size-label">500 m</span></label>
                <input id="size" type="range" min="50" max="5000" value="500">
            </div>
            <div class="field">
                <label for="speed"><span>Impact Velocity</span><span id="speed-label">25 km/s</span></label>
                <input id="speed" type="range" min="15" max="70" value="25">
            </div>
            <div class="field">
                <label for="angle"><span>Entry Angle</span><span id="angle-label">45°</span></label>
                <input id="angle" type="range" min="20" max="90" value="45">
            </div>
            <button id="start-button">INITIATE SIMULATION</button>
            <p class="hint">Use your mouse to control the camera: <br> <b>Left-Drag:</b> Orbit | <b>Scroll:</b> Zoom | <b>Right-Drag:</b> Pan</p>
        </div>
    </div>
    <div id="data-overlay">
        <p>Altitude: <span id="altitude-val">--</span> km</p>
        <p>Velocity: <span id="velocity-val">--</span> km/s</p>
    </div>
    <div id="impact-report"></div>
    <div id="restart-button" title="Restart Simulation">↺</div>

    <script>
        const BENGALURU_LAT = 12.9716;
        const BENGALURU_LON = 77.5946;

        let scene, camera, renderer, controls, earth, atmosphere, clouds, meteor, plasmaSheath;
        let particles = { trail: [], ejecta: [] };
        let cameraShake = { active: false, intensity: 0, decay: 0.95 };
        let simState = { running: false, stage: 'idle', frameCount: 0, progress: 0 };
        let animationId;
        let audio = { synth: null, noise: null, impact: null };
        let craterDecals = { lava: null, scorch: null };
        let trajectory;

        const ui = {
            overlay: document.getElementById('overlay-container'),
            startBtn: document.getElementById('start-button'),
            restartBtn: document.getElementById('restart-button'),
            dataOverlay: document.getElementById('data-overlay'),
            impactReport: document.getElementById('impact-report'),
            sizeSlider: document.getElementById('size'),
            speedSlider: document.getElementById('speed'),
            angleSlider: document.getElementById('angle'),
            altitudeVal: document.getElementById('altitude-val'),
            velocityVal: document.getElementById('velocity-val')
        };
        
        ui.startBtn.addEventListener('click', startSimulation);
        ui.restartBtn.addEventListener('click', () => location.reload());
        ui.sizeSlider.addEventListener('input', e => {
            const size = e.target.value;
            document.getElementById('size-label').textContent = size < 1000 ? `${size} m` : `${(size/1000).toFixed(1)} km`;
        });
        ui.speedSlider.addEventListener('input', e => document.getElementById('speed-label').textContent = `${e.target.value} km/s`);
        ui.angleSlider.addEventListener('input', e => document.getElementById('angle-label').textContent = `${e.target.value}°`);

        function startSimulation() {
            ui.overlay.style.opacity = '0';
            setTimeout(() => {
                ui.overlay.style.display = 'none';
                ui.dataOverlay.style.display = 'block';
            }, 500);

            simState.running = true;
            simState.stage = 'approach';

            Tone.start();
            audio.noise = new Tone.Noise("brown").toDestination();
            audio.noise.volume.value = -60;
            audio.impact = new Tone.MembraneSynth({ pitchDecay: 0.08, octaves: 10, oscillator: { type: "sine" }, envelope: { attack: 0.001, decay: 0.8, sustain: 0.01, release: 2 } }).toDestination();

            init();
            animate();
        }
        
        function init() {
            scene = new THREE.Scene();
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(-30, 20, 50);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            const sunLight = new THREE.DirectionalLight(0xfffde8, 1.2);
            sunLight.position.set(50, 20, 30);
            scene.add(sunLight);
            scene.add(new THREE.AmbientLight(0x404040, 0.5));

            const cubeLoader = new THREE.CubeTextureLoader();
            const spaceTexture = cubeLoader.load(['https://threejsfundamentals.org/threejs/resources/images/cubemaps/space/px.jpg','https://threejsfundamentals.org/threejs/resources/images/cubemaps/space/nx.jpg','https://threejsfundamentals.org/threejs/resources/images/cubemaps/space/py.jpg','https://threejsfundamentals.org/threejs/resources/images/cubemaps/space/ny.jpg','https://threejsfundamentals.org/threejs/resources/images/cubemaps/space/pz.jpg','https://threejsfundamentals.org/threejs/resources/images/cubemaps/space/nz.jpg']);
            scene.background = spaceTexture;

            const textureLoader = new THREE.TextureLoader();
            const earthTexture = textureLoader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg');
            const earthBumpMap = textureLoader.load('https://threejs.org/examples/textures/planets/earth_topology_512.jpg');
            const earthSpecularMap = textureLoader.load('https://threejs.org/examples/textures/planets/earth_specular_2048.jpg');
            const cloudTexture = textureLoader.load('https://threejs.org/examples/textures/planets/earth_clouds_1024.png');

            const earthGeo = new THREE.SphereGeometry(10, 128, 128);
            const earthMat = new THREE.MeshPhongMaterial({ map: earthTexture, bumpMap: earthBumpMap, bumpScale: 0.05, specularMap: earthSpecularMap, specular: new THREE.Color('grey'), shininess: 8 });
            earth = new THREE.Mesh(earthGeo, earthMat);
            
            const impactQuaternion = new THREE.Quaternion().setFromEuler(new THREE.Euler(THREE.MathUtils.degToRad(BENGALURU_LAT - 90), THREE.MathUtils.degToRad(BENGALURU_LON + 90), 0, 'YXZ'));
            earth.quaternion.multiply(impactQuaternion);
            scene.add(earth);

            const atmoGeo = new THREE.SphereGeometry(10.25, 128, 128);
            const atmoMat = new THREE.ShaderMaterial({ vertexShader: `varying vec3 vNormal; void main() { vNormal = normalize( normalMatrix * normal ); gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }`, fragmentShader: `varying vec3 vNormal; void main() { float intensity = pow( 0.5 - dot( vNormal, vec3( 0, 0, 1.0 ) ), 4.0 ); gl_FragColor = vec4( 0.5, 0.7, 1.0, 1.0 ) * intensity; }`, blending: THREE.AdditiveBlending, side: THREE.BackSide, transparent: true });
            atmosphere = new THREE.Mesh(atmoGeo, atmoMat);
            atmosphere.quaternion.copy(earth.quaternion);
            scene.add(atmosphere);

            const cloudGeo = new THREE.SphereGeometry(10.05, 128, 128);
            const cloudMat = new THREE.MeshPhongMaterial({ map: cloudTexture, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending });
            clouds = new THREE.Mesh(cloudGeo, cloudMat);
            clouds.quaternion.copy(earth.quaternion);
            scene.add(clouds);

            const impactPoint = new THREE.Vector3(10, 0, 0).applyQuaternion(earth.quaternion);
            const entryAngle = THREE.MathUtils.degToRad(ui.angleSlider.value);
            const startDistance = 70;
            const normal = impactPoint.clone().normalize();
            const tangent = new THREE.Vector3().crossVectors(normal, new THREE.Vector3(0,1,0)).normalize();
            const entryDirection = tangent.clone().applyAxisAngle(normal, Math.PI * 2 * Math.random()).multiplyScalar(Math.cos(entryAngle)).add(normal.clone().multiplyScalar(-Math.sin(entryAngle)));
            const startPoint = impactPoint.clone().add(entryDirection.clone().multiplyScalar(-startDistance));
            const controlPoint = new THREE.Vector3().addVectors(startPoint, impactPoint).multiplyScalar(0.5);
            controlPoint.add(controlPoint.clone().normalize().multiplyScalar(-15));
            trajectory = new THREE.QuadraticBezierCurve3(startPoint, controlPoint, impactPoint);

            const meteorGeo = new THREE.DodecahedronGeometry(1, 2);
            const meteorPositions = meteorGeo.attributes.position;
            for (let i = 0; i < meteorPositions.count; i++) {
                const vertex = new THREE.Vector3().fromBufferAttribute(meteorPositions, i);
                vertex.add(vertex.clone().normalize().multiplyScalar(Math.random() * 0.2));
                meteorPositions.setXYZ(i, vertex.x, vertex.y, vertex.z);
            }
            const meteorMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.8, metalness: 0.2 });
            meteor = new THREE.Mesh(meteorGeo, meteorMat);
            const meteorSize = ui.sizeSlider.value / 10000;
            meteor.scale.set(meteorSize, meteorSize, meteorSize);
            scene.add(meteor);

            const plasmaGeo = new THREE.SphereGeometry(1.2, 16, 16);
            const plasmaMat = new THREE.MeshBasicMaterial({ color: 0xffa500, transparent: true, opacity: 0, blending: THREE.AdditiveBlending });
            plasmaSheath = new THREE.Mesh(plasmaGeo, plasmaMat);
            meteor.add(plasmaSheath);
            
            controls.target.copy(earth.position);
            window.addEventListener('resize', onWindowResize);

            // --- Starfield ---
            const starVertices = [];
               for (let i = 0; i < 80000; i++) {
                const x = (Math.random() - 0.5) * 15000;
                const y = (Math.random() - 0.5) * 15000;
                const z = (Math.random() - 0.5) * 15000;
                starVertices.push(x, y, z);
}
              const starGeometry = new THREE.BufferGeometry();
              starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
              const starMaterial = new THREE.PointsMaterial({
                 color: 0xffffff,
                 size: 2.5,
                 transparent: true,
                 opacity: 1
});
const starfield = new THREE.Points(starGeometry, starMaterial);
scene.add(starfield);

        
        }
        
        function onImpact() {
            simState.stage = 'impact';
            const impactPosition = trajectory.getPoint(1);
            
            const mass = 1500 * (4/3) * Math.PI * Math.pow(ui.sizeSlider.value / 2, 3);
            const velocity = ui.speedSlider.value * 1000;
            const kineticEnergy = 0.5 * mass * Math.pow(velocity, 2);
            const megatons = kineticEnergy / 4.184e15;
            const craterDiameterKm = (25 * Math.pow(megatons, 1/3.4)) / 1000;
            const intensity = Math.log10(kineticEnergy) / 5;

            ui.impactReport.innerHTML = `<h2>Impact Analysis</h2><p>Impact Energy (J): <span>${kineticEnergy.toExponential(2)}</span></p><p>Impact Energy (MT): <span>${megatons.toFixed(2)}</span></p><p>Est. Crater Diameter: <span>${craterDiameterKm.toFixed(2)} km</span></p>`;
            ui.impactReport.style.display = 'block';
            
            audio.noise.stop();
            audio.impact.triggerAttackRelease("C1", "2n");

            const craterSize = Math.min(3.5, intensity * 0.5);
            const craterDepth = craterSize * 0.5;
            const localImpactPoint = earth.worldToLocal(impactPosition.clone());
            const positions = earth.geometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const vertex = new THREE.Vector3().fromBufferAttribute(positions, i);
                const dist = vertex.distanceTo(localImpactPoint);
                if (dist < craterSize) {
                    const falloff = Math.pow(1 - (dist / craterSize), 2);
                    const displacement = vertex.clone().normalize().multiplyScalar(-craterDepth * falloff);
                    vertex.add(displacement);
                    positions.setXYZ(i, vertex.x, vertex.y, vertex.z);
                }
            }
            positions.needsUpdate = true;
            earth.geometry.computeVertexNormals();
            
            const loader = new THREE.TextureLoader();
            const lavaTexture = loader.load('');
            lavaTexture.wrapS = lavaTexture.wrapT = THREE.RepeatWrapping;
            const scorchTexture = loader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/explosion.png');
            const noiseTexture = loader.load('https://threejs.org/examples/textures/lava/cloud.png');
            noiseTexture.wrapS = noiseTexture.wrapT = THREE.RepeatWrapping;

            const decalGeo = new THREE.PlaneGeometry(craterSize * 2, craterSize * 2);
            
            const lavaMat = new THREE.ShaderMaterial({
                uniforms: {
                    lavaTexture: { value: lavaTexture },
                    noiseTexture: { value: noiseTexture },
                    time: { value: 0.0 },
                    brightness: { value: 5.0 } 
                },
                vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
                fragmentShader: `
                    uniform sampler2D lavaTexture;
                    uniform sampler2D noiseTexture;
                    uniform float time;
                    uniform float brightness;
                    varying vec2 vUv;

                    void main() {
                        vec2 distortedUv = vUv + (texture2D(noiseTexture, vUv * 2.0 + time * 0.2).r - 0.5) * 0.15;
                        vec3 lavaColor = texture2D(lavaTexture, distortedUv * 2.0 + time * 0.1).rgb;
                        float coolFactor = 1.0 - time;
                        float glow = pow(lavaColor.r, 2.0) * 2.0 * coolFactor;
                        vec3 hotColor = mix(vec3(1.0, 0.1, 0.0), vec3(1.0, 0.9, 0.0), coolFactor * coolFactor);
                        vec3 finalColor = lavaColor * hotColor + glow * hotColor;
                        float alpha = coolFactor > 0.05 ? 1.0 : coolFactor / 0.05;
                        gl_FragColor = vec4(finalColor * brightness, alpha);
                    }`,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            const scorchMat = new THREE.MeshPhongMaterial({ map: scorchTexture, transparent: true, opacity: 0, depthTest: true, depthWrite: false, polygonOffset: true, polygonOffsetFactor: -4 });

            craterDecals.lava = new THREE.Mesh(decalGeo.clone(), lavaMat);
            craterDecals.scorch = new THREE.Mesh(decalGeo.clone(), scorchMat);
            
            [craterDecals.lava, craterDecals.scorch].forEach(decal => {
                earth.add(decal);
                decal.position.copy(impactPosition.clone().normalize().multiplyScalar(10.001));
                decal.lookAt(impactPosition.clone().normalize().multiplyScalar(11));
            });
            
            setTimeout(() => {
                if(meteor && meteor.parent) scene.remove(meteor);
            }, 50);

            cameraShake.active = true;
            cameraShake.intensity = intensity * 0.5;
            
            setTimeout(() => { ui.restartBtn.style.display = 'flex'; }, 3000);
        }

        function createParticles(count, material, life) {
            for (let i = 0; i < count; i++) {
                const size = 0.05 + Math.random() * 0.05;
                const particle = new THREE.Mesh(new THREE.SphereGeometry(size, 4, 4), material.clone());
                particle.userData = { life: life + Math.random() * life, initialLife: life + Math.random() * life };
                const tangent = trajectory.getTangent(simState.progress).multiplyScalar(-1);
                particle.position.copy(meteor.position).add(tangent.multiplyScalar(0.2));
                particle.userData.velocity = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).multiplyScalar(0.02);
                scene.add(particle);
                particles.trail.push(particle);
            }
        }

        function animate() {
            animationId = requestAnimationFrame(animate);
            simState.frameCount++;

            controls.update();
            earth.rotation.y += 0.0005;
            clouds.rotation.y += 0.0007;
            atmosphere.rotation.y += 0.0005;

            if (simState.running && simState.stage !== 'impact') {
                const speed = ui.speedSlider.value / 4000;
                simState.progress = Math.min(1, simState.progress + speed);
                const newPos = trajectory.getPoint(simState.progress);
                meteor.position.copy(newPos);
                const tangent = trajectory.getTangent(simState.progress);
                meteor.lookAt(newPos.clone().add(tangent));
                
                const distance = meteor.position.distanceTo(earth.position);
                const altitude = Math.max(0, (distance - 10) * 637.1);
                ui.altitudeVal.textContent = altitude.toFixed(0);
                ui.velocityVal.textContent = ui.speedSlider.value;

                if (distance < 10.3 && simState.stage === 'approach') {
                    simState.stage = 'entry';
                    audio.noise.start();
                    audio.noise.volume.rampTo(-20, 1);
                }

                if (simState.stage === 'entry') {
                    plasmaSheath.material.opacity = Math.min(0.9, plasmaSheath.material.opacity + 0.02);
                    plasmaSheath.scale.multiplyScalar(1.03);
                    if (simState.frameCount % 2 === 0) {
                        const trailMat = new THREE.MeshBasicMaterial({ color: 0xffd3a3, transparent: true, blending: THREE.AdditiveBlending });
                        createParticles(5, trailMat, 40);
                    }
                }

                if (simState.progress >= 1) { onImpact(); }
            }
            
            if (craterDecals.lava) {
                const lavaMaterial = craterDecals.lava.material;
                if (lavaMaterial.uniforms.time.value < 1.0) {
                    lavaMaterial.uniforms.time.value += 0.003; 
                    lavaMaterial.uniforms.brightness.value = Math.max(0.8, lavaMaterial.uniforms.brightness.value * 0.985);
                    craterDecals.scorch.material.opacity = Math.min(0.85, craterDecals.scorch.material.opacity + 0.005);
                }
            }

            for (let i = particles.trail.length - 1; i >= 0; i--) {
                const p = particles.trail[i];
                p.userData.life -= 1;
                p.position.add(p.userData.velocity);
                p.material.opacity = p.userData.life / p.userData.initialLife;
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    p.geometry.dispose();
                    p.material.dispose();
                    particles.trail.splice(i, 1);
                }
            }
            
            if (cameraShake.active && !controls.autoRotate) {
                 const shake = new THREE.Vector3((Math.random() - 0.5) * cameraShake.intensity, (Math.random() - 0.5) * cameraShake.intensity, (Math.random() - 0.5) * cameraShake.intensity);
                 camera.position.add(shake);
                 cameraShake.intensity *= cameraShake.decay;
                 if (cameraShake.intensity < 0.01) {
                     cameraShake.active = false;
                 }
            }
            
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ==================== ADDITIONAL FEATURES EXTENSION ====================
        // (Appended after your original code - hooks into existing animate() and onImpact())

        //////////////////////////////////////////////////////
        // 🌍 IMPACT ZONE VISUALIZATION (ring placed on Earth surface)
        //////////////////////////////////////////////////////
        let impactZoneMesh = null;
        function createImpactZoneMesh() {
            const ringGeo = new THREE.RingGeometry(0.6, 0.8, 128);
            const ringMat = new THREE.MeshBasicMaterial({
                color: 0xff3300,
                transparent: true,
                opacity: 0.0,
                side: THREE.DoubleSide,
            });
            impactZoneMesh = new THREE.Mesh(ringGeo, ringMat);
            // ring initially points +Z; rotate to lie flat on surface
            impactZoneMesh.rotation.x = Math.PI / 2;
            // make sure it doesn't occlude badly
            impactZoneMesh.renderOrder = 999;
            return impactZoneMesh;
        }

        function triggerImpactZoneEffectAt(positionWorld, maxScale = 6) {
            if (!impactZoneMesh) {
                impactZoneMesh = createImpactZoneMesh();
                scene.add(impactZoneMesh);
            }
            // place ring on Earth's surface by projecting normalized position to radius ~10.001
            const posNormalized = positionWorld.clone().normalize().multiplyScalar(10.001);
            impactZoneMesh.position.copy(posNormalized);
            // orient ring to local normal (make it face outward from Earth center)
            impactZoneMesh.lookAt(posNormalized.clone().multiplyScalar(2));
            impactZoneMesh.material.opacity = 0.95;
            impactZoneMesh.scale.set(0.01, 0.01, 0.01);

            let scale = 0.01;
            const expand = () => {
                scale += 0.12;
                const s = Math.min(scale, maxScale);
                impactZoneMesh.scale.set(s, s, s);
                // fade opacity as it expands
                impactZoneMesh.material.opacity = Math.max(0, impactZoneMesh.material.opacity - 0.012);
                if (impactZoneMesh.material.opacity > 0.01) {
                    requestAnimationFrame(expand);
                } else {
                    // after fade out, keep tiny presence for a short while then hide
                    setTimeout(() => {
                        if (impactZoneMesh) {
                            impactZoneMesh.material.opacity = 0;
                            impactZoneMesh.scale.set(0.01,0.01,0.01);
                        }
                    }, 600);
                }
            };
            expand();
        }

        //////////////////////////////////////////////////////
        // ☄️ ATMOSPHERIC ENTRY TRAIL (point-sprite tail)
        //////////////////////////////////////////////////////
        // Create trail buffer only once (safe because this script runs after init)
        const TRAIL_COUNT = 180;
        let trailPositions = new Float32Array(TRAIL_COUNT * 3);
        let trailAge = new Float32Array(TRAIL_COUNT);
        let trailIndex = 0;
        let trailPoints = null;
        function initTrail() {
            const bufGeo = new THREE.BufferGeometry();
            bufGeo.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
            bufGeo.setAttribute('age', new THREE.BufferAttribute(trailAge, 1));
            const mat = new THREE.PointsMaterial({
                size: 0.06,
                transparent: true,
                opacity: 0.9,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            trailPoints = new THREE.Points(bufGeo, mat);
            scene.add(trailPoints);
            // initialize ages to large so they don't show
            for (let i = 0; i < TRAIL_COUNT; i++) trailAge[i] = 1000;
            trailPoints.geometry.attributes.age.needsUpdate = true;
        }

        function pushTrailPoint(worldPos) {
            // add at current index
            trailPositions[trailIndex * 3] = worldPos.x;
            trailPositions[trailIndex * 3 + 1] = worldPos.y;
            trailPositions[trailIndex * 3 + 2] = worldPos.z;
            trailAge[trailIndex] = 0.0;
            trailIndex = (trailIndex + 1) % TRAIL_COUNT;
            if (trailPoints) {
                trailPoints.geometry.attributes.position.needsUpdate = true;
                trailPoints.geometry.attributes.age.needsUpdate = true;
            }
        }

        function updateTrailPoints() {
            if (!meteor || !trailPoints) return;
            // slowly increase ages and fade
            for (let i = 0; i < TRAIL_COUNT; i++) {
                trailAge[i] += 1.0;
            }
            // update point opacities by rewriting material.opacity (coarse approach)
            // better visual: scale points by age or use a shader; keep it simple here
            const posAttr = trailPoints.geometry.attributes.position;
            // remove very old points visually by moving them far away (cheap)
            for (let i = 0; i < TRAIL_COUNT; i++) {
                if (trailAge[i] > 140) {
                    posAttr.setXYZ(i, 9999, 9999, 9999);
                }
            }
            posAttr.needsUpdate = true;
            // occasionally push current meteor position for visible tail while in entry
            if (simState.stage === 'entry') {
                pushTrailPoint(meteor.position.clone());
            }
        }

        //////////////////////////////////////////////////////
        // 💥 SHOCKWAVE & EXPLOSION ANIMATION (spherical wave)
        //////////////////////////////////////////////////////
        let activeShockwaves = [];
        function createShockwaveAt(worldPos) {
            const geo = new THREE.SphereGeometry(0.2, 48, 48);
            const mat = new THREE.MeshBasicMaterial({
                color: 0xff8844,
                transparent: true,
                opacity: 0.5,
                side: THREE.BackSide,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            const wave = new THREE.Mesh(geo, mat);
            wave.position.copy(worldPos);
            scene.add(wave);
            activeShockwaves.push(wave);

            // expand and fade
            let s = 0.2;
            const expand = () => {
                s += 0.4;
                wave.scale.set(s, s, s);
                wave.material.opacity = Math.max(0, wave.material.opacity - 0.006);
                if (wave.material.opacity > 0.01) {
                    requestAnimationFrame(expand);
                } else {
                    // remove
                    scene.remove(wave);
                    wave.geometry.dispose();
                    if (wave.material.map) wave.material.map.dispose();
                    wave.material.dispose();
                    const idx = activeShockwaves.indexOf(wave);
                    if (idx !== -1) activeShockwaves.splice(idx, 1);
                }
            };
            expand();
        }

        //////////////////////////////////////////////////////
        // 📊 IMPACT DATA HUD
        //////////////////////////////////////////////////////
        const impactHUD = document.createElement('div');
        impactHUD.style.position = 'absolute';
        impactHUD.style.top = '430px';
        impactHUD.style.right = '0px';
        impactHUD.style.padding = '10px 14px';
        impactHUD.style.background = 'rgba(0,0,0,0.45)';
        impactHUD.style.color = '#00ffcc';
        impactHUD.style.fontFamily = 'Roboto Mono, monospace';
        impactHUD.style.fontSize = '16.2px';
        impactHUD.style.border = '1px solid rgba(0,255,200,0.12)';
        impactHUD.style.borderRadius = '8px';
        impactHUD.style.zIndex = 9999;
        impactHUD.innerHTML = `<b>Impact Data</b><br>Altitude: -- km<br>Velocity: -- km/s<br>Kinetic: -- MT<br>Temp: -- K`;
        document.body.appendChild(impactHUD);

        function updateImpactHUD() {
            if (!meteor || !trajectory || !earth) return;
            // altitude: same formula as your code (converted roughly)
            const distance = meteor.position.distanceTo(earth.position);
            const altitudeKm = Math.max(0, (distance - 10) * 637.1);
            // velocity: use slider (km/s)
            const velocity = parseFloat(ui.speedSlider.value) || 0;
            // compute kinetic energy using same mass estimate as onImpact (mass in kg)
            const mass = 1500 * (4/3) * Math.PI * Math.pow(ui.sizeSlider.value / 2, 3);
            const vel_m_s = velocity * 1000;
            const kineticJ = 0.5 * mass * Math.pow(vel_m_s, 2);
            const kineticMT = kineticJ / 4.184e15;
            const tempEst = 300 + velocity * 120; // simple empirical estimate
            impactHUD.innerHTML = `<b>Impact Data</b><br>Altitude: ${altitudeKm.toFixed(0)} km<br>Velocity: ${velocity.toFixed(1)} km/s<br>Kinetic: ${kineticMT.toFixed(2)} MT<br>Temp: ${tempEst.toFixed(0)} K`;
        }

        //////////////////////////////////////////////////////
        // 🔁 Hook into your existing animate() loop safely
        //////////////////////////////////////////////////////
        // Save references to original functions (they exist above)
        const __originalAnimate = typeof animate === 'function' ? animate : null;
        const __originalOnImpact = typeof onImpact === 'function' ? onImpact : null;

        // initialize trail after scene exists
        try { initTrail(); } catch(e) { /* in odd contexts, initTrail will be available later */ }

        // override animate to call original then our updates
        if (__originalAnimate) {
            animate = function () {
                __originalAnimate(); // call original loop (renders etc.)
                // our per-frame updates (non-invasive)
                try {
                    if (!trailPoints) initTrail();
                    updateTrailPoints();
                    updateImpactHUD();
                } catch (err) {
                    // fail safe - do nothing else
                    // console.warn('Extension animate hook error', err);
                }
            };
        } else {
            // fallback: if animate not defined yet (unlikely), create one
            animate = function () {
                requestAnimationFrame(animate);
                if (scene && camera && renderer) renderer.render(scene, camera);
                updateTrailPoints();
                updateImpactHUD();
            };
        }

        //////////////////////////////////////////////////////
        // 🚀 Hook into onImpact to trigger visual extras
        //////////////////////////////////////////////////////
        if (__originalOnImpact) {
            onImpact = function () {
                // capture impact position (world coords) from trajectory
                let impactPosWorld = null;
                try {
                    if (typeof trajectory !== 'undefined') impactPosWorld = trajectory.getPoint(1).clone();
                } catch (e) { impactPosWorld = meteor ? meteor.position.clone() : new THREE.Vector3(0,0,0); }

                // call original logic (creates crater, audio, etc.)
                __originalOnImpact();

                // trigger the added visual effects
                try {
                    if (impactPosWorld) {
                        triggerImpactZoneEffectAt(impactPosWorld, 5.5);
                        createShockwaveAt(impactPosWorld);
                    } else if (meteor) {
                        triggerImpactZoneEffectAt(meteor.position.clone(), 5.5);
                        createShockwaveAt(meteor.position.clone());
                    }
                } catch (err) {
                    // ignore extension errors
                }
            };
        } else {
            // If onImpact isn't present for some reason, try to hook into the point where simState.progress reaches 1
            // (But your code defines onImpact, so this branch will not be used).
        }

        // =====================================================================
        // small safe cleanup on reload/unload so WebGL contexts are tidy (optional)
        // =====================================================================
        window.addEventListener('beforeunload', () => {
            try {
                if (trailPoints) {
                    trailPoints.geometry.dispose();
                    if (trailPoints.material) trailPoints.material.dispose();
                }
                if (impactZoneMesh) {
                    impactZoneMesh.geometry.dispose();
                    if (impactZoneMesh.material) impactZoneMesh.material.dispose();
                }
            } catch(e){}
        });

        // ==================== END OF EXTENSION ====================
    </script>
</body>
</html>
