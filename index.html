<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Meteor Impact Simulation</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
    #restartBtn {
      position: absolute;
      top: 20px;
      left: 20px;
      width: 40px;
      height: 40px;
      font-size: 24px;
      background: rgba(100, 16, 133, 0.562);
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: transform 0.2s;
    }
    #restartBtn:hover {
      transform: rotate(20deg);
    }
  </style>
</head>
<body>
  <button id="restartBtn" title="Restart Simulation">&#x21bb;</button>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>

  <script>
    let scene, camera, renderer;
    let planet, planetRadius = 4.55;
    let meteor,  meteorTrail = []; meteorActive = true;
    let debris = [];
    let impactDone = false;

    init();
    animate();

    function init(){
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Lights
      const light = new THREE.PointLight(0xffffff, 1.5, 100);
      light.position.set(10, 10, 10);
      scene.add(light);
      scene.add(new THREE.AmbientLight(0x404040));

      // Mars (with your texture)
      const marsTexture = new THREE.TextureLoader().load("mars_texture.png");
      const geometry = new THREE.SphereGeometry(planetRadius, 900, 900);
      const material = new THREE.MeshPhongMaterial({ map: marsTexture, flatShading: true });
      planet = new THREE.Mesh(geometry, material);
      planet.position.x = -7;
      scene.add(planet);

      
      // Meteor (with your texture)
      const meteorTexture = new THREE.TextureLoader().load("meteor_texture.png");
      const meteorGeo = new THREE.DodecahedronGeometry(0.55, 0);
      const meteorMat = new THREE.MeshPhongMaterial({ map: meteorTexture, flatShading: true });
      meteor = new THREE.Mesh(meteorGeo, meteorMat);
      meteor.position.set(19, 5, 0.7);
      scene.add(meteor);

      camera.position.z = 20;

      // Stars background
      addStars();

      // Restart button
      document.getElementById("restartBtn").onclick = () => location.reload();
    }

    // Stars
    function addStars() {
      const starGeometry = new THREE.BufferGeometry();
      const starCount = 2000;
      const positions = [];
      for (let i = 0; i < starCount; i++) {
        const x = (Math.random() - 0.5) * 2000;
        const y = (Math.random() - 0.5) * 2000;
        const z = (Math.random() - 0.5) * 2000;
        positions.push(x, y, z);
      }
      starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1 });
      const stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(stars);
    }

    // Shockwave effect
    function createShockwave(position) {
      const geometry = new THREE.RingGeometry(1, 1.2, 64);
      const material = new THREE.MeshBasicMaterial({
        color: 0xff6600,
        transparent: true,
        opacity: 0.8,
        side: THREE.DoubleSide
      });
      const ring = new THREE.Mesh(geometry, material);

      const dir = new THREE.Vector3().subVectors(position, planet.position).normalize();
      ring.position.copy(dir.clone().multiplyScalar(planetRadius + 0.05).add(planet.position));
      ring.lookAt(planet.position);

      scene.add(ring);

      let scale = 1;
      const interval = setInterval(() => {
        scale += 0.05;
        ring.scale.set(scale, scale, scale);
        material.opacity -= 0.02;

        if (material.opacity <= 0) {
          scene.remove(ring);
          clearInterval(interval);
        }
      }, 30);
    }

    // Crater
    function addCrater(hitPos){
      const craterGeo = new THREE.CircleGeometry(1.5, 32);
      const craterMat = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide });
      const crater = new THREE.Mesh(craterGeo, craterMat);

      const dir = new THREE.Vector3().subVectors(hitPos, planet.position).normalize();
      crater.position.copy(dir.clone().multiplyScalar(planetRadius + 0.05).add(planet.position));
      crater.lookAt(planet.position);
      planet.add(crater);
    }

    // Debris spread evenly
    function spawnDebris(position){
      const debrisCount = 20;
      for(let i=0; i<debrisCount; i++){
        const size = 0.2;
        const geom = new THREE.BoxGeometry(size,size,size);
        const mat = new THREE.MeshPhongMaterial({color:0x882200});
        const mesh = new THREE.Mesh(geom,mat);
        mesh.position.copy(position);
        scene.add(mesh);

        // Spread evenly in spherical directions
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const speed = 0.2 + Math.random() * 0.2;
        const vx = speed * Math.sin(phi) * Math.cos(theta);
        const vy = speed * Math.cos(phi);
        const vz = speed * Math.sin(phi) * Math.sin(theta);

        debris.push({mesh, velocity:new THREE.Vector3(vx,vy,vz)});
      }
    }

    function animate(){
      requestAnimationFrame(animate);

      // Spin planet (right-to-left)
      planet.rotation.y -= 0.002;

      if(meteorActive){
        meteor.position.x -= 0.1;
        meteor.position.y -= 0.02;

        // Meteor trail
        const trail = new THREE.Mesh(
          new THREE.SphereGeometry(0.1, 8, 8),
          new THREE.MeshBasicMaterial({color: 0xff6600, transparent: true, opacity: 0.6})
        );
        trail.position.copy(meteor.position);
        scene.add(trail);
        meteorTrail.push({mesh: trail, life: 30});
      }

      // Fade trail
      meteorTrail.forEach((t, i) => {
        t.life--;
        t.mesh.material.opacity -= 0.02;
        if(t.life <= 0){
          scene.remove(t.mesh);
          meteorTrail.splice(i, 1);
        }
      });

      // Check collision
      if(!impactDone && meteor.position.distanceTo(planet.position) < planetRadius){
        impactDone = true;
        meteorActive = false;
        scene.remove(meteor);

        spawnDebris(meteor.position);
        addCrater(meteor.position);
        createShockwave(meteor.position);
      }

      // Move debris
      debris.forEach(d => {
        d.mesh.position.add(d.velocity);
      });

      renderer.render(scene, camera);
    }

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
