<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Meteor Impact Simulation</title>
<style>
  body { margin: 0; overflow: hidden; background: black; }
  canvas { display: block; }
  #restartBtn {
  position: absolute;
  top: 20px;
  left: 20px;
  width: 40px;
  height: 40px;
  font-size: 24px;
  background: rgba(255, 85, 0, 0.8);
  color: white;
  border: none;
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  justify-content: center;
  align-items: center;
  transition: transform 0.2s;
}
#restartBtn:hover {
  transform: rotate(20deg);

  }
</style>
</head>
<body>
<!-- Replace button with a small icon -->
<button id="restartBtn" title="Restart Simulation">&#x21bb;</button>


<script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>

<script>
// --- Scene & Camera ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
camera.position.z = 50;

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- Lights ---
scene.add(new THREE.AmbientLight(0x404040));
const dirLight = new THREE.DirectionalLight(0xffffff,1.2);
dirLight.position.set(50,50,50);
scene.add(dirLight);

// --- Starfield ---
const starCount = 2000;
const positions = [];
for(let i=0;i<starCount;i++){
    positions.push((Math.random()-0.5)*2000);
    positions.push((Math.random()-0.5)*2000);
    positions.push((Math.random()-0.5)*2000);
}
const starGeometry = new THREE.BufferGeometry();
starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions,3));
const starMaterial = new THREE.PointsMaterial({color:0xffffff,size:1});
scene.add(new THREE.Points(starGeometry,starMaterial));

// --- Planet ---
const planetRadius = 15;
const planetGeometry = new THREE.SphereGeometry(planetRadius,256,256);

// Procedural texture for stripes & patches
const size = 1024;
const canvas = document.createElement('canvas');
canvas.width = canvas.height = size;
const ctx = canvas.getContext('2d');
ctx.fillStyle = '#8B4513';
ctx.fillRect(0,0,size,size);

// Stripes
for(let i=0;i<500;i++){
    const x = Math.random()*size;
    const y = Math.random()*size;
    const w = 5 + Math.random()*10;
    const h = 1 + Math.random()*3;
    const shade = Math.floor(Math.random()*40);
    ctx.fillStyle = `rgb(${139-shade},${69-shade},${19-shade})`;
    ctx.fillRect(x,y,w,h);
}

// Patches
for(let i=0;i<80;i++){
    const x = Math.random()*size;
    const y = Math.random()*size;
    const radius = 5 + Math.random()*10;
    const shade = Math.floor(Math.random()*50);
    ctx.fillStyle = `rgb(${139-shade},${69-shade},${19-shade})`;
    ctx.beginPath();
    ctx.arc(x,y,radius,0,Math.PI*2);
    ctx.fill();
}

const texture = new THREE.CanvasTexture(canvas);
texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
texture.repeat.set(1,1);
const planetMaterial = new THREE.MeshStandardMaterial({map: texture, roughness:1, metalness:0});
const planet = new THREE.Mesh(planetGeometry,planetMaterial);
planet.position.x = -10;
scene.add(planet);

// --- Physics ---
const world = new CANNON.World();
world.gravity.set(0,-9.82,0);
const planetBody = new CANNON.Body({mass:0, shape:new CANNON.Sphere(planetRadius)});
planetBody.position.copy(planet.position);
world.addBody(planetBody);

// --- Meteor ---
const meteorGeometry = new THREE.IcosahedronGeometry(1,0);
const meteorMaterial = new THREE.MeshStandardMaterial({color:0xff8800});
const meteor = new THREE.Mesh(meteorGeometry, meteorMaterial);
scene.add(meteor);

// Meteor initial position and direction toward planet center
let meteorPos = new THREE.Vector3(30,15,0);
const speedMag = 0.35;
const meteorSpeed = new THREE.Vector3().subVectors(planet.position, meteorPos).normalize().multiplyScalar(speedMag);

// --- Fire Trail with gradient ---
const trailParticles = [];
const trailCount = 50;
for(let i=0;i<trailCount;i++){
    const geom = new THREE.SphereGeometry(0.15,6,6);
    const mat = new THREE.MeshBasicMaterial({color:0xffff00, transparent:true, opacity:1});
    const particle = new THREE.Mesh(geom, mat);
    particle.visible = false;
    particle.age = 0;
    scene.add(particle);
    trailParticles.push(particle);
}
let trailIndex = 0;

function updateTrail(){
    const p = trailParticles[trailIndex];
    p.position.copy(meteor.position);
    p.visible = true;
    p.scale.set(1,1,1);
    p.material.opacity = 1;
    p.age = 0;
    trailIndex = (trailIndex+1) % trailCount;

    trailParticles.forEach(particle => {
        if(!particle.visible) return;
        particle.position.addScaledVector(meteorSpeed.clone().negate(), 1);
        particle.age += 1;
        particle.scale.multiplyScalar(0.95);
        particle.material.opacity *= 0.9;

        if(particle.age < 5) particle.material.color.set(0xffff00); // yellow
        else if(particle.age < 10) particle.material.color.set(0xffaa00); // orange
        else particle.material.color.set(0xff3300); // red

        if(particle.material.opacity < 0.05) particle.visible = false;
    });
}

// --- Debris ---
const debris = [];
function spawnDebris(position){
    const debrisCount = 20;
    for(let i=0; i<debrisCount; i++){
        const size = 0.2 + Math.random()*0.2;
        const geom = new THREE.BoxGeometry(size,size,size);
        const mat = new THREE.MeshPhongMaterial({color:0x882200});
        const mesh = new THREE.Mesh(geom,mat);
        scene.add(mesh);

        const body = new CANNON.Body({
            mass:0.1,
            shape:new CANNON.Box(new CANNON.Vec3(size/2,size/2,size/2)),
            position:new CANNON.Vec3(position.x,position.y,position.z)
        });

        // Spherical distribution for even spread
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const speed = 5 + Math.random() * 2;
        const vx = speed * Math.sin(phi) * Math.cos(theta);
        const vy = speed * Math.cos(phi);
        const vz = speed * Math.sin(phi) * Math.sin(theta);
        body.velocity.set(vx, vy, vz);

        world.addBody(body);
        debris.push({mesh,body});
    }
}

// --- Impact patch ---
function addImpactPatch(hitPos){
    const patchGeometry = new THREE.CircleGeometry(3, 32);
    const patchMaterial = new THREE.MeshBasicMaterial({
        color: 0x000000,
        side: THREE.DoubleSide
    });
    const patch = new THREE.Mesh(patchGeometry, patchMaterial);

    const dir = new THREE.Vector3().subVectors(hitPos, planet.position).normalize();
    patch.position.copy(dir.clone().multiplyScalar(planetRadius + 0.05).add(planet.position));
    patch.lookAt(dir.clone().multiplyScalar(2).add(planet.position));

    planet.add(patch);
}

// --- Animate ---
let impactHappened = false;
function animate(){
    requestAnimationFrame(animate);

    // Planet spin (right to left)
    planet.rotation.y -= 0.002;

    world.step(1/60);

    // Meteor movement
    if(!impactHappened){
        meteorPos.add(meteorSpeed);
        meteor.position.copy(meteorPos);
    }

    // Trail
    if(!impactHappened) updateTrail();

    // Debris update
    debris.forEach(obj=>{
        obj.mesh.position.copy(obj.body.position);
        obj.mesh.quaternion.copy(obj.body.quaternion);
    });

    // Impact detection
    if(!impactHappened && meteorPos.distanceTo(planet.position) <= planetRadius+1){
        impactHappened = true;

        // Remove meteor and trail
        scene.remove(meteor);
        trailParticles.forEach(p=>p.visible=false);

        // Debris
        spawnDebris(meteorPos);

        // Dark impact patch
        addImpactPatch(meteorPos);
    }

    renderer.render(scene,camera);
}
animate();

// --- Restart ---
document.getElementById("restartBtn").addEventListener("click",()=>location.reload());

// --- Resize ---
window.addEventListener("resize", ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>

